import { IChartApi, ISeriesApi, UTCTimestamp } from "lightweight-charts";
import { DrawingData } from "../services/drawingApi";
import { Candle, Interval } from "../types";

interface ChartPoint {
  time: number;
  price: number;
}

export class ChartDrawingManager {
  private chart: IChartApi;
  private series: ISeriesApi<"Candlestick">;
  private interval: Interval;
  private candles: Candle[];
  private canvas: HTMLCanvasElement | null = null;
  private ctx: CanvasRenderingContext2D | null = null;
  private drawings: Map<string, DrawingData> = new Map();
  private isDrawing = false;
  private startPoint: ChartPoint | null = null;
  private currentMousePoint: ChartPoint | null = null;
  private currentTool: "line" | "fib" | "rectangle" | "none" = "none";
  private onDrawingComplete: ((drawing: DrawingData) => Promise<void>) | null = null;
  private animationFrame: number | null = null;

  constructor(
    chart: IChartApi,
    series: ISeriesApi<"Candlestick">,
    interval: Interval,
    candles: Candle[]
  ) {
    this.chart = chart;
    this.series = series;
    this.interval = interval;
    this.candles = candles;
    this.setupCanvas();
    this.startRenderLoop();
  }

  updateCandles(candles: Candle[]): void {
    this.candles = candles;
  }

  private setupCanvas(): void {
    const chartElement = document.querySelector('[data-chart-container]');
    if (!chartElement) return;

    let canvas = chartElement.querySelector("canvas.drawing-canvas") as HTMLCanvasElement;
    if (!canvas) {
      canvas = document.createElement("canvas");
      canvas.className = "drawing-canvas";
      canvas.style.position = "absolute";
      canvas.style.top = "0";
      canvas.style.left = "0";
      canvas.style.width = "100%";
      canvas.style.height = "100%";
      canvas.style.zIndex = "5";
      // 初始状态不捕获事件
      canvas.style.pointerEvents = "none";
      chartElement.appendChild(canvas);

      // 在画布上监听事件
      canvas.addEventListener("mousedown", (e) => this.onMouseDown(e));
      canvas.addEventListener("mousemove", (e) => this.onMouseMove(e));
      canvas.addEventListener("mouseup", (e) => this.onMouseUp(e));
      canvas.addEventListener("mouseleave", () => this.onMouseLeave());
      
      // 允许滚轮事件穿透，用于缩放
      canvas.addEventListener("wheel", (e) => {
        // 不阻止，让事件穿透到图表
      }, { passive: true });
    }

    this.canvas = canvas;
    this.ctx = canvas.getContext("2d");
    this.resizeCanvas();
  }

  private onMouseLeave(): void {
    // 鼠标离开画布时的清理
  }

  private resizeCanvas(): void {
    if (!this.canvas) return;
    const container = this.canvas.parentElement;
    if (!container) return;
    this.canvas.width = container.clientWidth;
    this.canvas.height = container.clientHeight;
  }

  private startRenderLoop(): void {
    const render = () => {
      this.redraw();
      this.animationFrame = requestAnimationFrame(render);
    };
    this.animationFrame = requestAnimationFrame(render);
  }

  private screenToChartPoint(screenX: number, screenY: number): ChartPoint | null {
    const timeScale = this.chart.timeScale();
    let price = this.series.coordinateToPrice(screenY);

    // 如果价格为 null，可能在图表边缘，尝试获取可见范围的价格
    if (price === undefined || price === null) {
      const visibleRange = this.series.priceScale().getApplyOptions();
      // 使用图表可见区域的中间价格
      if (this.candles.length > 0) {
        const lastCandle = this.candles[this.candles.length - 1];
        price = lastCandle.close;
      } else {
        return null;
      }
    }

    // 找到最近的K线时间（对齐到K线中轴）
    let nearestCandle: Candle | null = null;
    let minDistance = Infinity;

    for (const candle of this.candles) {
      const candleCoord = timeScale.timeToCoordinate(candle.time as UTCTimestamp);
      if (candleCoord !== null && candleCoord !== undefined) {
        const distance = Math.abs(screenX - candleCoord);
        if (distance < minDistance) {
          minDistance = distance;
          nearestCandle = candle;
        }
      }
    }

    // 如果没找到K线或距离太远，尝试推算未来K线
    if (!nearestCandle || minDistance > 100) {
      if (this.candles.length > 0) {
        const lastCandle = this.candles[this.candles.length - 1];
        const lastCoord = timeScale.timeToCoordinate(lastCandle.time as UTCTimestamp);
        
        if (lastCoord !== null && lastCoord !== undefined && screenX > lastCoord) {
          // 鼠标在最后一根K线右边，推算未来K线
          const intervalSeconds = this.getIntervalSeconds();
          const pixelsPerBar = this.candles.length > 1 
            ? Math.abs(
                (timeScale.timeToCoordinate(this.candles[this.candles.length - 1].time as UTCTimestamp) || 0) -
                (timeScale.timeToCoordinate(this.candles[this.candles.length - 2].time as UTCTimestamp) || 0)
              )
            : 20;
          
          const barOffset = Math.round((screenX - lastCoord) / pixelsPerBar);
          const futureTime = lastCandle.time + barOffset * intervalSeconds;
          return { time: Math.round(futureTime), price };
        }
      }
    }

    if (!nearestCandle) {
      return null;
    }

    return { time: nearestCandle.time, price };
  }

  private getIntervalSeconds(): number {
    const intervals: { [key: string]: number } = {
      '1m': 60,
      '3m': 180,
      '5m': 300,
      '15m': 900,
      '30m': 1800,
      '1h': 3600,
      '2h': 7200,
      '4h': 14400,
      '6h': 21600,
      '12h': 43200,
      '1d': 86400,
      '1w': 604800,
    };
    return intervals[this.interval] || 60;
  }

  private chartToScreenPoint(chartPoint: ChartPoint): { x: number; y: number } | null {
    const timeScale = this.chart.timeScale();
    const priceCoord = this.series.priceToCoordinate(chartPoint.price);

    if (priceCoord === undefined || priceCoord === null) {
      return null;
    }

    // 先尝试直接获取坐标（时间点刚好是当前周期的K线）
    let timeCoord = timeScale.timeToCoordinate(chartPoint.time as UTCTimestamp);

    // 如果找不到，说明时间点不在当前周期的K线上，需要找到包含该时间的K线
    if (timeCoord === undefined || timeCoord === null) {
      // 找到包含该时间点的K线（时间 <= chartPoint.time 的最近K线）
      let containingCandle: Candle | null = null;
      
      for (const candle of this.candles) {
        if (candle.time <= chartPoint.time) {
          if (!containingCandle || candle.time > containingCandle.time) {
            containingCandle = candle;
          }
        }
      }

      // 如果找到包含的K线，使用它的中轴坐标
      if (containingCandle) {
        timeCoord = timeScale.timeToCoordinate(containingCandle.time as UTCTimestamp);
      } else {
        // 如果时间在第一根K线之前或最后一根K线之后（未来时间）
        if (this.candles.length > 0) {
          if (chartPoint.time < this.candles[0].time) {
            // 在第一根K线之前
            return null;
          } else {
            // 在最后一根K线之后（未来时间）
            const lastCandle = this.candles[this.candles.length - 1];
            const lastCoord = timeScale.timeToCoordinate(lastCandle.time as UTCTimestamp);
            
            if (lastCoord !== null && lastCoord !== undefined) {
              const intervalSeconds = this.getIntervalSeconds();
              const pixelsPerBar = this.candles.length > 1 
                ? Math.abs(
                    (timeScale.timeToCoordinate(this.candles[this.candles.length - 1].time as UTCTimestamp) || 0) -
                    (timeScale.timeToCoordinate(this.candles[this.candles.length - 2].time as UTCTimestamp) || 0)
                  )
                : 20;
              
              // 计算未来K线的偏移
              const timeDiff = chartPoint.time - lastCandle.time;
              const barOffset = Math.ceil(timeDiff / intervalSeconds);
              
              timeCoord = lastCoord + barOffset * pixelsPerBar;
            }
          }
        }
      }
    }

    if (timeCoord === undefined || timeCoord === null) {
      return null;
    }

    return { x: timeCoord, y: priceCoord };
  }

  setTool(tool: "line" | "fib" | "rectangle" | "none"): void {
    this.currentTool = tool;
    if (this.canvas) {
      const chartContainer = this.canvas.parentElement;
      
      if (tool === "none") {
        this.canvas.style.cursor = "default";
        this.canvas.style.pointerEvents = "none";
        if (chartContainer) {
          chartContainer.style.cursor = "";
        }
      } else {
        // 绘图工具激活时，只接收点击事件，不阻止滚轮和拖动
        this.canvas.style.cursor = "crosshair";
        // 使用 auto 接收事件，但在事件处理中判断是否阻止传播
        this.canvas.style.pointerEvents = "auto";
        
        // 在父容器上也设置光标样式
        if (chartContainer) {
          chartContainer.style.cursor = "crosshair";
        }
      }
    }
  }

  setOnDrawingComplete(callback: (drawing: DrawingData) => Promise<void>): void {
    this.onDrawingComplete = callback;
  }

  loadDrawings(drawings: DrawingData[]): void {
    this.drawings.clear();
    for (const drawing of drawings) {
      if (drawing.id) {
        this.drawings.set(drawing.id, drawing);
      }
    }
  }

  addDrawing(drawing: DrawingData): void {
    if (drawing.id) {
      this.drawings.set(drawing.id, drawing);
    }
  }

  private onMouseDown(event: MouseEvent): void {
    if (this.currentTool === "none" || !this.canvas) return;

    // 右键或中键允许拖动图表，不绘制
    if (event.button !== 0) {
      return;
    }

    // 如果按住 Shift/Ctrl/Alt 键，允许拖动图表，不绘制
    if (event.shiftKey || event.ctrlKey || event.altKey || event.metaKey) {
      return;
    }

    const rect = this.canvas.getBoundingClientRect();
    const screenX = event.clientX - rect.left;
    const screenY = event.clientY - rect.top;

    const chartPoint = this.screenToChartPoint(screenX, screenY);
    
    // 只在有效的图表点时才绘制，否则允许滚轮缩放和拖动
    if (!chartPoint) {
      // 不阻止事件，允许图表交互
      return;
    }

    // 阻止事件传播到图表，避免拖动
    event.stopPropagation();
    event.preventDefault();

    if (!this.isDrawing) {
      // 第一次点击：开始绘制
      this.isDrawing = true;
      this.startPoint = chartPoint;
      this.currentMousePoint = chartPoint;
    } else if (this.startPoint) {
      // 第二次点击：完成绘制
      const endChartPoint = chartPoint;

      // 检查移动距离
      if (
        Math.abs(endChartPoint.time - this.startPoint.time) < 1 &&
        Math.abs(endChartPoint.price - this.startPoint.price) < 0.00001
      ) {
        this.isDrawing = false;
        this.startPoint = null;
        this.currentMousePoint = null;
        return;
      }

      const drawing = this.createDrawing(this.startPoint, endChartPoint);
      if (drawing) {
        // 立即添加到本地显示
        this.addDrawing(drawing);
        
        // 异步保存到后端
        if (this.onDrawingComplete) {
          this.onDrawingComplete(drawing).catch((err) => {
            console.error("Failed to save drawing:", err);
            // 保存失败，移除本地图形
            this.removeDrawing(drawing.id);
          });
        }
      }

      this.isDrawing = false;
      this.startPoint = null;
      this.currentMousePoint = null;
    }
  }

  private onMouseMove(event: MouseEvent): void {
    if (!this.canvas) return;

    const rect = this.canvas.getBoundingClientRect();
    const screenX = event.clientX - rect.left;
    const screenY = event.clientY - rect.top;

    if (this.isDrawing) {
      const chartPoint = this.screenToChartPoint(screenX, screenY);
      if (chartPoint) {
        this.currentMousePoint = chartPoint;
      }
    }
  }

  private onMouseUp(event: MouseEvent): void {
    // 不需要鼠标抬起逻辑
  }

  private createDrawing(p1: ChartPoint, p2: ChartPoint): DrawingData | null {
    const tool = this.currentTool;
    if (tool === "none") return null;

    const drawing: DrawingData = {
      id: `drawing-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      symbol: "",
      interval: this.interval,
      tool: tool as "line" | "fib" | "rectangle",
      points: [
        { time: p1.time, price: p1.price },
        { time: p2.time, price: p2.price },
      ],
      color: "#22aa6a",
      lineWidth: 2,
    };

    return drawing;
  }

  private redraw(): void {
    if (!this.ctx || !this.canvas) return;

    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // 绘制已保存的图形
    for (const drawing of this.drawings.values()) {
      this.drawShape(drawing);
    }

    // 绘制实时预览
    if (this.isDrawing && this.startPoint && this.currentMousePoint) {
      this.drawPreview(this.startPoint, this.currentMousePoint);
    }
  }

  private drawPreview(startPoint: ChartPoint, currentPoint: ChartPoint): void {
    if (!this.ctx) return;

    const p1 = this.chartToScreenPoint(startPoint);
    const p2 = this.chartToScreenPoint(currentPoint);

    if (!p1 || !p2) return;

    const color = "#22aa6a";
    this.ctx.strokeStyle = color;
    this.ctx.fillStyle = `${color}20`;
    this.ctx.lineWidth = 2;

    if (this.currentTool === "line") {
      this.ctx.beginPath();
      this.ctx.moveTo(p1.x, p1.y);
      this.ctx.lineTo(p2.x, p2.y);
      this.ctx.stroke();
    } else if (this.currentTool === "rectangle") {
      const width = p2.x - p1.x;
      const height = p2.y - p1.y;
      this.ctx.fillRect(p1.x, p1.y, width, height);
      this.ctx.strokeStyle = color;
      this.ctx.lineWidth = 2;
      this.ctx.strokeRect(p1.x, p1.y, width, height);
    } else if (this.currentTool === "fib") {
      this.drawFibonacci(p1.y, p2.y, p1.x, p2.x, color);
    }

    // 绘制起点圆圈
    this.ctx.strokeStyle = color;
    this.ctx.lineWidth = 2;
    this.ctx.beginPath();
    this.ctx.arc(p1.x, p1.y, 5, 0, 2 * Math.PI);
    this.ctx.stroke();
  }

  private drawShape(drawing: DrawingData): void {
    if (!this.ctx || drawing.points.length < 2) return;

    const [p1Data, p2Data] = drawing.points;
    if (!p1Data.time || !p1Data.price || !p2Data.time || !p2Data.price) return;

    const p1 = this.chartToScreenPoint({ time: p1Data.time, price: p1Data.price });
    const p2 = this.chartToScreenPoint({ time: p2Data.time, price: p2Data.price });

    if (!p1 || !p2) return;

    const color = drawing.color || "#22aa6a";
    this.ctx.strokeStyle = color;
    this.ctx.fillStyle = `${color}20`;
    this.ctx.lineWidth = drawing.lineWidth || 2;

    if (drawing.tool === "line") {
      this.ctx.beginPath();
      this.ctx.moveTo(p1.x, p1.y);
      this.ctx.lineTo(p2.x, p2.y);
      this.ctx.stroke();
    } else if (drawing.tool === "rectangle") {
      const width = p2.x - p1.x;
      const height = p2.y - p1.y;
      this.ctx.fillRect(p1.x, p1.y, width, height);
      this.ctx.strokeStyle = color;
      this.ctx.lineWidth = drawing.lineWidth || 2;
      this.ctx.strokeRect(p1.x, p1.y, width, height);
    } else if (drawing.tool === "fib") {
      this.drawFibonacci(p1.y, p2.y, p1.x, p2.x, color);
    }
  }

  private drawFibonacci(y1: number, y2: number, x1: number, x2: number, color: string): void {
    if (!this.ctx) return;

    const levels = [0, 0.236, 0.382, 0.5, 0.618, 0.786, 1];

    this.ctx.strokeStyle = color;
    this.ctx.fillStyle = color;
    this.ctx.lineWidth = 1;
    this.ctx.font = "12px Arial";

    for (const level of levels) {
      const y = y1 + (y2 - y1) * level;
      this.ctx.beginPath();
      this.ctx.moveTo(x1, y);
      this.ctx.lineTo(x2, y);
      this.ctx.stroke();

      this.ctx.fillText(`${(level * 100).toFixed(1)}%`, x2 + 5, y + 4);
    }
  }

  removeDrawing(drawingId: string): void {
    this.drawings.delete(drawingId);
  }

  clearAll(): void {
    this.drawings.clear();
  }

  destroy(): void {
    if (this.animationFrame !== null) {
      cancelAnimationFrame(this.animationFrame);
    }
    if (this.canvas) {
      const chartContainer = this.canvas.parentElement;
      if (chartContainer) {
        chartContainer.style.cursor = "";
      }
      this.canvas.removeEventListener("mousedown", (e) => this.onMouseDown(e));
      this.canvas.removeEventListener("mousemove", (e) => this.onMouseMove(e));
      this.canvas.removeEventListener("mouseup", (e) => this.onMouseUp(e));
      this.canvas.removeEventListener("mouseleave", () => this.onMouseLeave());
      this.canvas.remove();
    }
  }
}
